// {{ project_name }} - Auth API Helpers
// API calls to HostKit Auth service
// Generated by HostKit for Next.js projects with auth

import type { AuthSession, AuthResponse } from '@/types/auth';

/**
 * HostKit Auth service URL.
 * Defaults to the project's hostkit.dev subdomain.
 */
const AUTH_URL = process.env.NEXT_PUBLIC_AUTH_URL || 'https://{{ project_name }}.hostkit.dev';

/**
 * Sign in with email and password.
 */
export async function signInWithEmail(email: string, password: string): Promise<AuthResponse> {
  const response = await fetch(`${AUTH_URL}/auth/login`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || error.message || 'Sign in failed');
  }

  return response.json();
}

/**
 * Register with email and password.
 */
export async function signUpWithEmail(email: string, password: string): Promise<AuthResponse> {
  const response = await fetch(`${AUTH_URL}/auth/register`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || error.message || 'Sign up failed');
  }

  return response.json();
}

/**
 * Sign in with Google ID token (for web OAuth or native apps).
 *
 * @param idToken - Google ID token from OAuth flow
 * @param webClientId - Optional web client ID for audience validation
 */
export async function signInWithGoogle(
  idToken: string,
  webClientId?: string
): Promise<AuthResponse> {
  const body: Record<string, string> = { id_token: idToken };
  if (webClientId) {
    body.web_client_id = webClientId;
  }

  const response = await fetch(`${AUTH_URL}/auth/oauth/google/verify-token`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || error.message || 'Google sign in failed');
  }

  return response.json();
}

/**
 * Sign in with Apple ID token (for native iOS apps).
 *
 * @param idToken - Apple ID token from Sign in with Apple
 * @param bundleId - Optional bundle ID for audience validation
 */
export async function signInWithApple(
  idToken: string,
  bundleId?: string
): Promise<AuthResponse> {
  const body: Record<string, string> = { id_token: idToken };
  if (bundleId) {
    body.bundle_id = bundleId;
  }

  const response = await fetch(`${AUTH_URL}/auth/oauth/apple/verify-token`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || error.message || 'Apple sign in failed');
  }

  return response.json();
}

/**
 * Request a magic link to be sent to the email.
 */
export async function sendMagicLink(email: string): Promise<void> {
  const response = await fetch(`${AUTH_URL}/auth/magic-link/send`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || error.message || 'Failed to send magic link');
  }
}

/**
 * Verify a magic link token.
 */
export async function verifyMagicLink(token: string): Promise<AuthResponse> {
  const response = await fetch(`${AUTH_URL}/auth/magic-link/verify`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ token }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || error.message || 'Invalid or expired magic link');
  }

  return response.json();
}

/**
 * Create an anonymous session.
 */
export async function createAnonymousSession(): Promise<AuthResponse> {
  const response = await fetch(`${AUTH_URL}/auth/anonymous`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || error.message || 'Failed to create anonymous session');
  }

  return response.json();
}

/**
 * Refresh the access token using a refresh token.
 */
export async function refreshAccessToken(refreshToken: string): Promise<AuthSession> {
  const response = await fetch(`${AUTH_URL}/auth/token/refresh`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ refresh_token: refreshToken }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || error.message || 'Token refresh failed');
  }

  return response.json();
}

/**
 * Revoke a refresh token (logout).
 */
export async function revokeToken(refreshToken: string): Promise<void> {
  const response = await fetch(`${AUTH_URL}/auth/token/revoke`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ refresh_token: refreshToken }),
  });

  // Ignore errors - we're signing out anyway
  if (!response.ok) {
    console.warn('Failed to revoke token on server');
  }
}

/**
 * Sign out - revokes the session and clears tokens.
 */
export async function signOut(accessToken: string): Promise<void> {
  await fetch(`${AUTH_URL}/auth/signout`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${accessToken}`,
    },
  });
  // Ignore errors - we're signing out anyway
}
