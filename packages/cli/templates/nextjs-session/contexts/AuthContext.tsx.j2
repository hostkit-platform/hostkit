'use client';

// {{ project_name }} - Auth Context
// Manages authentication state with iron-session for persistent login
// Generated by HostKit for Next.js projects with auth

import React, {
  createContext,
  useContext,
  useEffect,
  useState,
  useCallback,
  useRef,
} from 'react';
import type { AuthUser, AuthSession, AuthResponse } from '@/types/auth';
import type { SessionData } from '@/lib/session';
import {
  signInWithEmail,
  signUpWithEmail,
  signInWithGoogle as authSignInWithGoogle,
  signInWithApple as authSignInWithApple,
  refreshAccessToken,
  signOut as authSignOut,
} from '@/lib/auth';

interface AuthContextValue {
  user: AuthUser | null;
  session: AuthSession | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  signIn: (email: string, password: string) => Promise<void>;
  signUp: (email: string, password: string) => Promise<void>;
  signInWithGoogle: (idToken: string, webClientId?: string) => Promise<void>;
  signInWithApple: (idToken: string, bundleId?: string) => Promise<void>;
  signOut: () => Promise<void>;
  refreshToken: () => Promise<string | null>;
}

const AuthContext = createContext<AuthContextValue | null>(null);

// Session API helpers
async function getServerSession(): Promise<SessionData> {
  const res = await fetch('/api/session');
  return res.json();
}

async function saveServerSession(
  user: AuthUser,
  authSession: AuthSession
): Promise<SessionData> {
  const res = await fetch('/api/session', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ user, authSession }),
  });
  return res.json();
}

async function updateServerSession(updates: {
  authSession?: AuthSession;
}): Promise<SessionData> {
  const res = await fetch('/api/session', {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(updates),
  });
  return res.json();
}

async function destroyServerSession(): Promise<void> {
  await fetch('/api/session', { method: 'DELETE' });
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<AuthUser | null>(null);
  const [session, setSession] = useState<AuthSession | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const refreshTimerRef = useRef<NodeJS.Timeout | null>(null);

  const isAuthenticated = !!user && !!session;

  // Clear refresh timer
  const clearRefreshTimer = useCallback(() => {
    if (refreshTimerRef.current) {
      clearTimeout(refreshTimerRef.current);
      refreshTimerRef.current = null;
    }
  }, []);

  // Schedule proactive token refresh
  const scheduleTokenRefresh = useCallback(
    (expiresIn: number) => {
      clearRefreshTimer();
      // Refresh 1 minute before expiry, minimum 30 seconds
      const refreshTime = Math.max((expiresIn - 60) * 1000, 30000);
      refreshTimerRef.current = setTimeout(async () => {
        try {
          await refreshTokenInternal();
        } catch (error) {
          console.error('Proactive token refresh failed:', error);
        }
      }, refreshTime);
    },
    [clearRefreshTimer]
  );

  // Internal refresh token function
  const refreshTokenInternal = useCallback(async (): Promise<string | null> => {
    if (!session?.refresh_token) {
      return null;
    }

    try {
      const newSession = await refreshAccessToken(session.refresh_token);
      setSession(newSession);

      // Update server session with new tokens
      await updateServerSession({ authSession: newSession });

      scheduleTokenRefresh(newSession.expires_in);
      return newSession.access_token;
    } catch (error) {
      console.error('Token refresh failed:', error);
      // Clear auth state on refresh failure
      setUser(null);
      setSession(null);
      await destroyServerSession();
      return null;
    }
  }, [session, scheduleTokenRefresh]);

  // Handle successful authentication
  const handleAuthSuccess = useCallback(
    async (response: AuthResponse) => {
      setUser(response.user);
      setSession(response.session);

      // Save to server session (httpOnly cookie)
      await saveServerSession(response.user, response.session);

      scheduleTokenRefresh(response.session.expires_in);
    },
    [scheduleTokenRefresh]
  );

  // Initialize auth state from server session
  useEffect(() => {
    const initAuth = async () => {
      try {
        const serverSession = await getServerSession();

        if (
          serverSession.isLoggedIn &&
          serverSession.user &&
          serverSession.session
        ) {
          setUser(serverSession.user);
          setSession(serverSession.session);

          // Schedule token refresh based on remaining time
          scheduleTokenRefresh(serverSession.session.expires_in);
        }
      } catch (error) {
        console.error('Failed to restore session:', error);
      } finally {
        setIsLoading(false);
      }
    };

    initAuth();

    return () => clearRefreshTimer();
  }, [scheduleTokenRefresh, clearRefreshTimer]);

  // Sign in with email/password
  const signIn = useCallback(
    async (email: string, password: string) => {
      const response = await signInWithEmail(email, password);
      await handleAuthSuccess(response);
    },
    [handleAuthSuccess]
  );

  // Sign up with email/password
  const signUp = useCallback(
    async (email: string, password: string) => {
      const response = await signUpWithEmail(email, password);
      await handleAuthSuccess(response);
    },
    [handleAuthSuccess]
  );

  // Sign in with Google
  const signInWithGoogleHandler = useCallback(
    async (idToken: string, webClientId?: string) => {
      const response = await authSignInWithGoogle(idToken, webClientId);
      await handleAuthSuccess(response);
    },
    [handleAuthSuccess]
  );

  // Sign in with Apple
  const signInWithAppleHandler = useCallback(
    async (idToken: string, bundleId?: string) => {
      const response = await authSignInWithApple(idToken, bundleId);
      await handleAuthSuccess(response);
    },
    [handleAuthSuccess]
  );

  // Sign out
  const handleSignOut = useCallback(async () => {
    if (session?.access_token) {
      try {
        await authSignOut(session.access_token);
      } catch {
        // Ignore sign out errors
      }
    }
    setUser(null);
    setSession(null);
    clearRefreshTimer();
    await destroyServerSession();
  }, [session, clearRefreshTimer]);

  const value: AuthContextValue = {
    user,
    session,
    isLoading,
    isAuthenticated,
    signIn,
    signUp,
    signInWithGoogle: signInWithGoogleHandler,
    signInWithApple: signInWithAppleHandler,
    signOut: handleSignOut,
    refreshToken: refreshTokenInternal,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth(): AuthContextValue {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
